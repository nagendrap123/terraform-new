infrastructure
=============
infra is very important to create a business

Disadvantages
---------------
1.manually created
2.time taken
3.follow the sequence
  create the sg
  create the ec2
  create r53 record
4.we need to check each and every resource and note down manually
5.cost analysis 
 
Iaas --- Infra as a code 
-------------------
1.version control --> we can maintain different version of infra
multiple persons can be colleborate to create infra
2.same infra across environments -->DEV,QA,PROD
working in DEV, failed in prod 
run the same code in all environments
that creates same infra everywhere 
3. CRUD 
4.inventory --> list of resources for the project in terms of infra.
5.dependancy--> dependancies would be automatically resolve while CRUD 
6.cost analysis--> creation and deletion takes less time, so cost can be reduced
7. code reuse: modules, you can reuse the infra code created multiple times for different 
projects
8. state management--> implicit feature 

Terraform 
----------------
HCL ---> Hashi corporation language

ec2 instance creation
=====================
1.security group 
2.ec2 instance creation 

terraform works with providers 
we are using AWS provider
so we should inform to the terraform we are using AWS 
1.provider configuration
--------------------------
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "5.57.0"
    }
  }
}

provider "aws" {
  # Configuration options
}

2.provide aws authentication details 
-----------------------------------
By using IAM user, to create access_key and secret_key 
aws configure --> aws cli already installed. so we can run aws configure in windows 
access key
xxxxxxxxx
secret key 
xxxxxxxxxxxxxxxxxx

command line interface
--------------------
C:\Users\nagen>aws configure
AWS Access Key ID [****************S6W2]: xxxxxxxxxxxxxxxxxxxx
AWS Secret Access Key [****************qxzo]: xxxxxxxxxxxxxxxxxx
Default region name [ap-south-1]: us-east-1
Default output format [None]:

provider "aws" {
  # Configuration options
}
we can also provide access details terraform aws details 
but that is not good practice we are getting alerts from git hub 
so we are providing only region details
provider "aws" {
  region = "us-east-1"
}
syntax
==========
resource <resource type> <resource name>
mandatory 
----------
resource
resource type 
we cannot change the names

security group creation
--------------------------
ingress {
from port = 0
to port = 0
protocol  = -1
}
0 - means all ports 
-1 = means all protocols

initialize terraform
---------------------
terraform init : terraform will check providers. it will download AWS providers and keep them 
terraform plan --- will show you what are the resources will create
validates the syntax, 
terraform apply -auto-approve
terraform destroy -auto-approve


 Error: creating Security Group (allow_ssh): UnauthorizedOperation: You are not authorized to perform this operation.
 ---------------------------------------------------------------------------------------------------------------
 your not a authorized person to create security groups
 you dont have the access
 
 variables
 ==========
 user= <variable value> #shell scritpng
 vars:
    key=value [ansible]

variable "variable name" {
  type = <data type>
  default = "<default value>"
}

syntax
=========
variable "image_id" {
    type = string
    default = "ami-041e2ea9402c46c32"
    description = "RHEL ami-id"
  
}

how can we call variable in terraform file 
------------------------------------------
var.<variable name>

tagging strategy 
-----------------
when its created 
who created
which environment
project name 
modules

what is block
--------------
ingress {
    from_port        = 22
    to_port          = 22
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
  }
for ingress there is "="
so this are called as block

so for this one also we are using variables
ingress {
    from_port        = var.ssh_port
    to_port          = var.ssh_port
    protocol         = var.protocol
    cidr_blocks      = var.allowing_cidr
  }

terraform.tfvars
===============
In variable declaration we can give default values
terraform.tfvars will override default values in variables
we have to same name in terraform.tfvars and variables.tf for the variable

if i am given "t3.small" .tfvars file and "t3.micro" given in variables.tf 
terraform will take the "t3.small"
+ instance_state                       = (known after apply)
+ instance_type                        = "t3.small"


terraform command line variables
===================================
-var=""
terraform plan -var="instance_type=t3.medium"

 + instance_state                       = (known after apply)
 + instance_type                        = "t3.medium"
 
 variables order priority 
 -----------------------
 command line variables
 .tfvars
 ENV variable
 variables.tf [default values]/ variable default value 
 
 Environment variables in Terraform
 ===============================
 export TF_VAR_instance_type=t3.large
 
 
***conditions***
================
expression ? "":""
expression ? "this will run if expression is true":"runs if false"

expense
---------
if DB, instance_type should be t3.small 

condition 
-------------
instance_type = var.instance_name == "db" ? "t3.small" : "t3.micro"

loops
-------
count based loops
for loops
dynamic block loops

count.index ----0,1,2,3

so have to create 3 instances at a time 
db,backend,frontend
count=3

terraform functions
=====================
for terraform functions we can use "terraform console"

$ terraform console

1.numeric functions
---------------------
abs
----
abs returns the absolute value of the given number. 
In other words, if the number is zero or positive then it is returned as-is, but if it is negative then it is multiplied by -1 to make it positive before returning it.

> abs(23)
> abs(23)
23
> abs(0)
> abs(0)
0
> abs(-12.4)
> abs(-12.4)
12.4

ceil
-----
ceil returns the closest whole number that is greater than or equal to the given value, which may be a fraction.

> ceil(6.5)
7
> ceil(7.1)
8
floor
-----
floor returns the closest whole number that is less than or equal to the given value, which may be a fraction
> floor(5.4)
> floor(5.4)
5
> floor(4)
> floor(4)
4

log 
----
log returns the logarithm of a given number in a given base.

syntax
-------
log(number, base)

> log(10,2)
> log(10,2)
3.3219280948873626
> log(16,2)
> log(16,2)
4
> ceil(log(10,2))
> ceil(log(10,2))
4

max 
----
max takes one or more numbers and returns the greatest number from the set

> max(12,15,16,25)
25

min 
---
min takes one or more numbers and returns the smallest number from the set.

> min(12,15,16,25)
12

parseint 
--------
parseint parses the given string as a representation of an integer in the specified base and returns the resulting number.
The base must be between 2 and 62 inclusive.

pow
------
pow calculates an exponent, by raising its first argument to the power of the second argument.

> pow(5,2)
> pow(5,2)
25
> pow(5,0)
> pow(5,0)
1
> pow(5,1)
> pow(5,1)
5

signum 
------
signum determines the sign of a number, returning a number between -1 and 1 to represent the sign.

> signum (-5)
> signum (-5)
-1
> signum (0)
> signum (0)
0
> signum (5)
> signum (5)
1

string functions
==================
chomp
------
chomp removes newline characters at the end of a string.

This can be useful if, for example, the string was read from a file that has a newline character at the end.

> chomp ("hello\n")
"hello"
> chomp ("hello\r\n")
> chomp ("hello\r\n")
"hello"

endswith 
-------
endswith takes two values: a string to check and a suffix string. The function returns true if the first string ends with that exact suffix.

endswith(string, suffix)

> endswith ("hello world","world")
> endswith ("hello world","world")
true
> endswith ("hello world", "hello")
> endswith ("hello world", "hello")
false

format
------
The format function produces a string by formatting a number of other values according to a specification string.

format(formatstring, ...arguments)

formatstring: A string that contains placeholders for variable substitution. Placeholders are denoted by % followed by a character indicating the type of value to be inserted.
arguments: One or more arguments that provide values to replace the placeholders in the formatstring.

placeholders
-------------
%s: Replaced by a string value.
%d, %f: Replaced by integer or float values respectively.
%t: Replaced by a boolean value (true or false).

> format ("they are %d digits",4)
"they are 4 digits"

> format ("hello, %s", "nag")
"hello, nag"
> format ("hello %s", "sruthi")
> format ("hello %s", "sruthi")
"hello sruthi"

> format("Hello, %s!", var.name)
Hello, Valentina!
> "Hello, ${var.name}!"
Hello, Valentina!

formatlist 
----------
formatlist produces a list of strings by formatting a number of other values according to a specification string.
output
------
> formatlist("Hello, %s!", ["Valentina", "Ander", "Olivia", "Sam"])
> formatlist("Hello, %s!", ["Valentina", "Ander", "Olivia", "Sam"])
tolist([
  "Hello, Valentina!",
  "Hello, Ander!",
  "Hello, Olivia!",
  "Hello, Sam!",
])

join 
-----
join produces a string by concatenating all of the elements of the specified list of strings with the specified separator.

join ("-", ["nagendra","parchuri","nellore"])
> join ("-", ["nagendra","parchuri","nellore"])
"nagendra-parchuri-nellore"

lower
-----
lower converts all cased letters in the given string to lowercase.

> lower("NAGENDRA")
"nagendra"

regex 
------
regex applies a regular expression to a string and returns the matching substrings.

replace
-------
replace searches a given string for another given substring, and replaces each occurrence with a given replacement string.

> replace ("5+1+2","+","-")
> replace ("5+1+2","+","-")
"5-1-2"
> replace ("hello world","/w.*d/","everybody")
>  replace ("hello world","/w.*d/","everybody")
"hello everybody"

split
-----
split produces a list by dividing a given string at all occurrences of a given separator

split(separator, string)

> split (",","nagendra,parchuri,nellore")
tolist([
  "nagendra",
  "parchuri",
  "nellore",
])

startswith 
---------
startswith takes two values: a string to check and a prefix string. The function returns true if the string begins with that exact prefix.

startswith(string, prefix)

substr 
-----
substr extracts a substring from a given string by offset and (maximum) length.


substr(string, offset, length)

> substr("hello world",1,4)
"ello"
> substr("hello world",0,4)
"hell"
its will starts with 0 to 1,2,3,...etc 

title
------
title converts the first letter of each word in the given string to uppercase.

> title("hello world")
"Hello World"

trimprefix
-----------
trimprefix removes the specified prefix from the start of the given string. If the string does not start with the prefix, the string is returned unchanged.

> trimprefix("helloworld", "hello")
world

> trimprefix("helloworld", "cat")
helloworld

trimspace
----------
trimspace removes any space characters from the start and end of the given string.


> trimspace("  hello\n\n")
hello

upper
-----
upper converts all cased letters in the given string to uppercase.

> upper("hello")
HELLO
> upper("алло!")
АЛЛО!

common tags in terraform
======================
project
environment
terraform

merge function
==============
tags = merge(
       var.common_tags,
       {
        Name = "Nagendra Parchuri"
       }
       )
length function and count function
-----------------------------------
variables
variable "instance_names" {
    type = list
    default = ["db","backend","frontend"]
  
}

count = length(var.instance_names)

terraform outputs 
=================
the output comes out list data type 

output "public_ip" {
  description = "The public IP address of the EC2 instance"
  value       = aws_instance.example.public_ip
}

output "private_ip" {
  description = "The private IP address of the EC2 instance"
  value       = aws_instance.example.private_ip
}

output "instance_type" {
  description = "The instance type of the EC2 instance"
  value       = aws_instance.example.instance_type
}


r53 
====
resource "aws_route53_record" "www" {
  zone_id = aws_route53_zone.primary.zone_id
  name    = "www.example.com"
  type    = "A"
  ttl     = 300
  records = [aws_eip.lb.public_ip]
}


Conditions
===========
if frontend nagdevops.online ----->public_ip
others db/backend.nagdevops.online ----->private ip

route53
========
resource "aws_route53_record" "expense" {
    count = length(var.instance_names)
  zone_id = var.zone_id
  name    = var.instance_names[count.index] == "frontend" ? var.domain_name : "${var.instance_names[count.index]}.${var.domain_name}"
  type    = "A"
  ttl     = 1
  records = var.instance_names[count.index] == "frontend" ? [aws_instance.expense[count.index].public_ip] : [aws_instance.expense[count.index].private_ip]
#if records already exists
allow_overwrite = true

}



Interpolation
=============
we mixed text and variable at a time is called interpolation


ansible "hello {{greetings}}" ----- interpolation
terraform ----------"hello ${var.greetings}" -----interpolation
. (dot) -- text/variable ---- it is a text 

name    = var.instance_names[count.index] == "frontend" ? var.domain_name : "${var.instance_names[count.index]}.${var.domain_name}"




	   








  